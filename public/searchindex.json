[{
  "section": "Blog",
  "slug": "/blog/auth/cas-%E8%AE%A4%E8%AF%81%E5%8D%8F%E8%AE%AE/",
  "title": "CAS认证协议",
  "description": "Centeral Authentication Service 基于web的单点登录认证协议。它允许一个用户通过一个凭证（如用户名和密码）在多个应用程序中实现身份验证。CAS主要用于web环境中，它通过提供一个中央服务器来处理认证请求，使得用户只需登录一次，就可以访问多个不同的服务。",
  "date": "2024年11月21日",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/auth/CAS_hu_df23f7a119d9d100.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"251\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/auth\\/CAS_hu_e1f779a679ba3fd0.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/auth/CAS_hu_511dfabdbb48fb76.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/auth\\/CAS_hu_31df4144fba04f06.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "认证, 协议",
  "tags": "OIDC, 认证",
  "content":"介绍 Centeral Authentication Service 基于web的单点登录认证协议。它允许一个用户通过一个凭证（如用户名和密码）在多个应用程序中实现身份验证。CAS 主要用于 web环境中，它通过提供一个中央服务器来处理认证请求，使得用户只需登录一次，就可以访问多个不同的服务。\n概念 CAS client: 需要单点登录访问的应用。 CAS server：负责处理用户的认证请求并提供一个集中的认证服务，主要功能：认证用户，生成票据，服务票据分发，票据验证。\nTGT:Ticket Granting Ticket用户身份认证成功后，CAS会为用户签发登录票据，通过此票据可以证明用户已经登录成功，后续的服务访问而无需重新认证，CAS会将此票据存储起来，可以有效期内一直使用。\n[!INFO] TGT是一种特殊的票据，它能够“授予”或生成其他类型的票据，即Service Ticket（ST）。当用户想要访问一个受保护的服务时，他们会使用TGT来请求一个ST，ST是用于访问特定服务的临时凭证。\nTGC：存储在浏览器中的认证中心 cookie,认证成功后会返回一个 TGC到浏览器，与 TGC关联。 ST：一个临时的、一次性的凭据，由认证服务器生成，并颁发给已经通过身份验证的用户。用户使用这个服务票据来访问一个或多个服务，而不需要在每个服务上重新进行身份验证。一旦服务票据被验证，它通常就会被废弃，以防止重放攻击。\n接入流程 第三方应用在认证中心进行服务注册，确保第三方应用能够通过认证中心进行单点登录。 第三方应用后台增加认证 filter（具体实现的话，可以是集成 cas apereo 的 cas-client相关依赖，也可以是集成 spring security cas相关依赖）。 cas client集成参考：cas client单点登录集成 认证过程 用户访问第三方应用的目标地址， 后台认证 filter检测到请求未认证，携带着目标地址重定向到认证中心的登录页面 用户登录成功之后，会生成用户登录成功的票据：TGT\u0026amp;TGC，并生成 ST,将 TGC和 ST返回给用户浏览器，重定向到第三方应用的目标地址，此时携带着 ST。 应用程序收到带有服务票据的请求后，会将其发送回 CAS服务器进行验证。 CAS服务器验证服务票据的有效性。如果服务票据有效，CAS服务器返回认证响应：是否成功，成功的话携带用户信息。ST使用后此时已失效，第三方应用可以据此创建会话。 当第三方应用会话过期或被清理后，如果 TGT还在有效期内，但此时 ST已经过期，还是会重定向到登录页面，不过此时不需要再次输入用户名密码，可能会看到页面闪烁（为了更好的用户体验，CAS实现可能会使用一个透明的中间页面或者直接在后台完成新的ST的发放，从而避免用户看到登录页面的闪现） 参考 CAS协议分析\nCAS认证原理\nCAS\n"},{
  "section": "Blog",
  "slug": "/blog/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/mysql%E5%AD%97%E7%AC%A6%E9%9B%86%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99/",
  "title": "mysql中的字符集",
  "description": "UTF-8是Unicode的一种实现方式，几乎包含世界上所有字符，方便国际化，通常使用此字符集。",
  "date": "2024年11月21日",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/database/mofulu_hu_49d9ff6ceae08944.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"308\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/database\\/mofulu_hu_9f13ed3d00e8738f.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/database/mofulu_hu_c318097c1a1bf99a.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/database\\/mofulu_hu_fd9edeaa088413a2.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "数据库, MySQL",
  "tags": "MySQL, 字符集",
  "content":"字符集 UTF-8是Unicode的一种实现方式，几乎包含世界上所有字符，方便国际化，通常使用此字符集。\nMySQL 中的 utf8 和 utf8mb4 UTF8 一个字符由 1-6 字节组成，但现在使用的字符最长只有 4 个字节。MySQL 中的 utf8 字符集最多只能存储 3 个字节，因此碰到 4 字节的字符就无法存储，这就是为什么 utf8 字符集的字段无法存储 emoji 表情的原因。 utf8mb4 是 utf8 的扩展，它可以存储 4 个字节的字符，因此可以存储 emoji 表情。 如无特殊情况，都应该使用 utf8mb4 字符集，不再使用 utf8 字符集。\n排序规则 是否区分大小写 ci（Case Insensitive）：这个排序规则表示大小写不敏感的排序。在使用ci排序规则时，大写和小写字母被视为相同，因此在排序字符串时不会考虑它们的大小写差异。例如，字符串 Apple和 apple在使用ci排序规则时会被视为相等。关键字搜索时**A%和a%**搜索的结果一致.\ncs（Case Sensitive）：这个排序规则表示大小写敏感的排序。在使用“cs”排序规则时，大写和小写字母被视为不同的字符，因此在排序字符串时会严格区分它们的大小写差异。例如，字符串 Apple和apple在使用cs排序规则时会被视为不同。 在创建数据库或表时，可以通过设置 COLLATE关键字来指定特定的排序规则。例如： utf8mb4_0900_ai_ci 名称解析：utf8mb4 是字符集，0900_ai_ci 是排序规则。ci 代表不区分大小写（case-insensitive）。 [[不同数据库中的特性]]\n是否区分重音 在某些特定场景下，区分重音是非常重要的。以下是一些需要区分重音的情况：\n需要区分重音的场景 语言特性：某些语言的词义可能因重音的不同而改变。例如，在法语中，“a”（有重音）和“à”（无重音）是两个不同的词，具有不同的含义。在这种情况下，区分重音是必要的。 精确匹配：在某些应用中，用户可能希望进行精确匹配，例如在搜索引擎或数据库查询中，用户输入的内容必须与数据库中的内容完全一致，包括重音。 文化和语言敏感性：在处理某些文化或语言时，重音可能会影响到用户的体验和理解，因此需要特别注意。 区分重音的排序规则 如果你需要在 MySQL 中区分重音，可以使用以下排序规则：\nutf8mb4_0900_as_cs：这个排序规则表示： as：区分重音（Accent Sensitive） cs：区分大小写（Case Sensitive） utf8mb4_general_ci：虽然这个排序规则是不区分重音的，但如果你需要更细致的控制，可以考虑使用 utf8mb4_unicode_ci，它在某些情况下会更准确地处理重音，但仍然是不区分重音的。 utf8mb4_unicode_as：如果你使用的是 MySQL 8.0 或更高版本，可以使用 utf8mb4_unicode_as，它支持区分重音。 示例 如果你想要创建一个表并使用区分重音的排序规则，可以使用以下 SQL 语句：\nCREATE TABLE example ( name VARCHAR(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_as_cs ); 在这个表中，name 列将区分重音和大小写。\n规则解析 utf8_general_ci 表示一种通用的排序规则。general 排序规则在比较字符时，采用了一些简化的规则，通常不会考虑重音符号（如 é 和 e 被视为相同），并且在比较时也不区分大小写（例如，A 和 a 被视为相同）。 utf8mb4_0900_ai_ci mysql8之后默认的字符集排序规则版本 0900：表示使用 Unicode 9.0 版本的字符集。 常见字符集 utf8mb4_general_ci ：不区分大小写, 校对速度快, 但准确度稍差，不区分重音。 通常可以选用 utf8mb4_bin:：字符串每个字符串用二进制数据编译存储。 区分大小写,而且可以存二进制的内容。 utf8mb4_unicode_ci：不区分大小写, 校准确度高,但校对速度稍慢。,区分重音\n参考： mysql的字符集和排序规则\nci,cs,bin\n"},{
  "section": "Blog",
  "slug": "/blog/auth/oauth2.0-%E6%8E%88%E6%9D%83%E5%8D%8F%E8%AE%AE/",
  "title": "Oauth2.0授权协议",
  "description": "OAuth2.0是一种授权协议，**允许第三方应用在用户授权的情况下，在不暴露用户密码给第三方应用的前提下安全地访问服务器资源**,同时可以提供有限的权限范围，限制第三方应用能够访问的资源，提高了安全性。认证成功之后会返回Acces Token，第三方应用可以用Access Token换取所需要的资源。",
  "date": "2024年11月21日",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/auth/oauth2.0-header_hu_d0fe6ce00a51e405.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"380\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/auth\\/oauth2.0-header_hu_63958f11635cb28a.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/auth/oauth2.0-header_hu_c71a3d632192f0db.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/auth\\/oauth2.0-header_hu_5848f07e0c98f8d3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "授权, 协议",
  "tags": "Oauth2.0, 授权",
  "content":"定义 OAuth2.0是一种授权协议，允许第三方应用在用户授权的情况下，在不暴露用户密码给第三方应用的前提下安全地访问服务器资源,同时可以提供有限的权限范围，限制第三方应用能够访问的资源，提高了安全性。认证成功之后会返回Acces Token，第三方应用可以用Access Token换取所需要的资源。\n重点概念 资源所有者：Resource Owner(RO)： 拥有受保护资源的实体，通常指终端用户。\n资源服务器：Resource Server（RS） 资源的存储位置。\n客户端：client 请求访问受保护资源的第三方应用。\n授权服务器：authorization server(AS) 验证资源身份者，颁发令牌。多数情况下授权服务器需要验证资源拥有者身份，授权服务器也要提供认证功能。\n授权令牌: Access Token（AT） 授权服务器提供给客户端访问受保护资源的第三方应用。\n授权许可：Authorization Grant 是资源拥有者授权给客户端的一个凭据，表明资源拥有者同意客户端代表他访问受保护的资源。授权许可的类型包括授权码、隐式授权、资源拥有者密码凭据和客户端凭据。\n整体流程 当第三方客户端 client需要访问资源拥有者 RO所拥有的资源的时候，向用户发出授权许可 Authorization Grant； 资源拥有者RO批准授权，将授权许可返回给第三方客户端； 第三方客户端拿着用户的授权许可去换取访问令牌 Access Token； 授权服务器 AS确定第三方客户端client身份和资源拥有者RO身份后返回访问令牌给第三方客户端； 第三方客户端使用访问令牌访问资源； 资源服务器 RS验证访问令牌（发送给授权服务器验证等），返回许可访问的资源， 四种授权方式 OAuth2.0支持四种授权方式，以适应不同的场景。\n新增概念 客户端凭据（Client Credentials）授权服务器验证客户端身份的凭证，通常是ClientId\u0026amp;ClientSecret\n授权码授权 概念 授权码流程是最常见的一种。使用的授权许可 Authorization Grant是授权码 Authorization Code，授权码在前端传递，有效期很短且单次有效，第三方应用后台服务获取到后授权码后，携带着客户端凭据和授权码到授权中心换取访问令牌 Access Token，再拿着访问令牌换取资源。\n流程 流程与OAuth2.0整体流程相似，关注点主要在： 第二步重定向到授权服务器地址的时候需要携带的参数：\nresponse_type：必填，其值通常是 code，表示客户端希望使用授权码流程。\nclient_id：必填，表示客户端的ID，这是在授权服务器上注册客户端时获得的。\nredirect_uri：必填，指定授权服务器在完成用户认证和授权后应该重定向用户的URI。这个URI必须在客户端注册时提供给授权服务器。\nscope：选填，用于指定客户端请求的权限范围。例如，read或 write等。\nstate：推荐，用于防止跨站请求伪造（CSRF）攻击。客户端生成一个随机值，并在授权请求中发送。授权服务器在重定向回客户端时应该原样返回这个值，客户端可以验证它以确认响应是来自预期的授权请求。\n请求示例\nGET /authorize?response_type=code\u0026amp;client_id=CLIENT_ID\u0026amp;redirect_uri=https%3A%2F%2Fclient.example.com%2Fcallback\u0026amp;scope=read%20write\u0026amp;state=xyz HTTP/1.1 Host: authorization-server.com 返回结果 对应第四步授权服务器携带着授权码重定向到第三方应用\nHTTP/1.1 302 Found Location: https://client.example.com/callback?code=SplxlOBeZQQYbYS6WxSbIA\u0026amp;state=xyz 第五步第三方应用携带着授权码请求访问令牌的时候需要的其他参数：\ngrant_type：必填，这个参数必须设置为 authorization_code，以指明客户端正在使用授权码授权流程。 code：必填，之前在授权请求阶段从授权服务器获得的授权码。 redirect_uri：必填，在用户授权时使用的重定向URI，必须与获取授权码时使用的重定向URI相同。 client_id：必填，客户端应用的ID，这是在应用注册授权服务器时获得的。 client_secret：推荐，通常情况客户端应用的密钥，这是在应用注册授权服务器时获得的。某些授权服务器可能要求在请求访问令牌时提供这个参数，以提高安全性。 请求示例 POST /token HTTP/1.1 Host: authorization-server.com Authorization: Basic base64encode(client_id:client_secret) -- 不同实现可能传入位置不同 Content-Type: application/x-www-form-urlencoded grant_type=authorization_code code=SplxlOBeZQQYbYS6WxSbIA -- 上个接口返回的 redirect_uri=REDIRECT_URI 响应示例：\nHTTP/1.1 200 OK Content-Type: application/json;charset=UTF-8 { \u0026#34;access_token\u0026#34;: \u0026#34;ACCESS_TOKEN\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;Bearer\u0026#34;, \u0026#34;expires_in\u0026#34;: 3600, \u0026#34;refresh_token\u0026#34;: \u0026#34;REFRESH_TOKEN\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;read write\u0026#34; } 优缺点\u0026amp;使用场景 安全性高:不会暴露Access Token,适合于大多数第三方应用； 有服务端：适用于有服务端的场景； 流程略复杂； 隐式授权 隐式（implicit）授权 ,不会生成授权码，会直接返回access token到前端,使用较少。\n流程 与授权码授权相比，隐式授权不返回授权码，直接返回了Access Token ,少了拿授权码换取Access Token的步骤。 重点关注的还是第二步： 第三方应用将用户浏览器重定向到授权服务器，并在请求中包含以下参数：\nresponse_type: 必须设置为 token，表示客户端请求直接返回访问令牌。\nclient_id: 客户端的标识符，注意：此模式无client secret。\nredirect_uri: 用户授权后授权服务器重定向到的URI。\nscope: 客户端请求的权限范围。\nstate: 客户端生成的一个随机字符串，用于防止跨站请求伪造（CSRF）攻击。\n请求示例\nGET /authorize?response_type=token\u0026amp;client_id=CLIENT_ID\u0026amp;redirect_uri=https://client-app.com/callback\u0026amp;scope=read_profile\u0026amp;state=随机字符串 HTTP/1.1 Host: authorization-server.com **响应示例** HTTP/1.1 302 Found Location: https://client-app.com/callback#access_token=ACCESS_TOKEN\u0026amp;token_type=bearer\u0026amp;expires_in=3600\u0026amp;scope=read_profile\u0026amp;state=随机字符串 优缺点\u0026amp;\u0026amp;适用场景 安全性较低：由于访问令牌直接在浏览器中传输，因此更容易受到中间人攻击。 无法刷新令牌：隐式授权流程不支持刷新令牌，一旦访问令牌过期，用户需要重新进行授权。 令牌泄露风险：由于令牌直接在客户端传递，如果客户端存在安全漏洞，令牌可能会被泄露。 无后端参与：适合纯前端，没有后端的网站。 密码授权 密码模式授权，直接将用户名密码交给第三方应用。这种方式不符合OAuth2.0的原则：第三方应用不应该拥有用户的凭证，增加了凭证泄露的风险。\n流程 步骤上重点在于第二步，第三方应用需要拿着用户的用户名密码去请求token。\n请求示例：\nPOST /token HTTP/1.1 Host: authorization-server.com Authorization: Basic base64encode(client_id:client_secret) Content-Type: application/x-www-form-urlencoded grant_type=password\u0026amp;username=USER\u0026amp;password=PASSWORD\u0026amp;scope=read 响应示例：\nHTTP/1.1 200 OK Content-Type: application/json;charset=UTF-8 { \u0026#34;access_token\u0026#34;:\u0026#34;2YotnFZFEjr1zCsicMWpAA\u0026#34;, \u0026#34;token_type\u0026#34;:\u0026#34;bearer\u0026#34;, \u0026#34;expires_in\u0026#34;:3600, \u0026#34;scope\u0026#34;:\u0026#34;read\u0026#34; } 优缺点\u0026amp;适用场景 安全性较低：客户端需要存储用户的用户名和密码，这增加了安全风险，尤其是在客户端遭受攻击的情况下。 信任问题：需要用户高度信任客户端应用，因为用户需要将自己的凭证信息提供给客户端。客户端应用高度信任，例如第一方应用。 不一定支持刷新令牌：虽然密码授权流程可以返回刷新令牌，但不是所有实现都支持，这意味着当访问令牌过期时，用户可能需要重新提供用户名和密码。 不适用于第三方应用：由于安全问题，密码授权不适用于第三方应用，因为第三方应用通常不被用户高度信任。 凭证授权 凭证（Client Credentials）授权主要用于服务器间通信的场景，适用于后台服务需要访问受保护的资源，不涉及到具体用户的资源访问，这部分资源应该是归属于后台服务的。\n流程 重点关注第二步，客户端使用其 client_id 和 client_secret 向授权服务器发送请求，请求一个访问令牌。这个请求通常不需要用户参与。\n请求示例\nPOST /token HTTP/1.1 Host: authorization-server.com Authorization: Basic base64encode(client_id:client_secret) Content-Type: application/x-www-form-urlencoded grant_type=client_credentials 响应示例\nHTTP/1.1 200 OK Content-Type: application/json;charset=UTF-8 Cache-Control: no-store Pragma: no-cache { \u0026#34;access_token\u0026#34;:\u0026#34;2YotnFZFEjr1zCsicMWpAA\u0026#34;, \u0026#34;token_type\u0026#34;:\u0026#34;Bearer\u0026#34;, \u0026#34;expires_in\u0026#34;:3600, \u0026#34;scope\u0026#34;:\u0026#34;read write\u0026#34; } 优缺点\u0026amp;适用场景 无用户参与：这种模式不需要用户交互，因此适用于没有用户参与的服务间通信。 访问令牌不包含用户信息：由于不涉及用户，因此访问令牌通常不包含用户信息。 有限的权限：通常，使用 Client Credentials 授权模式获得的访问令牌只能访问有限的资源或执行有限的操作，因为这些操作与最终用户无关。 适用于服务器到服务器的通信的有限数据访问的授权，不需要用户授权数据的场景。 refresh token 它用于在访问令牌（access token）过期后获取新的访问令牌，而无需用户再次进行身份验证。Refresh token 是一种长期有效的令牌，通常在用户同意应用程序进行授权后发放。\n与访问令牌不同，refresh token 不用于访问资源。它只在后台使用，用于获取新的访问令牌。当访问令牌过期时，客户端应用程序可以使用 refresh token 向授权服务器请求新的访问令牌，而无需用户参与。\n参考 Oauth2.0\nOAuth2.0 vs OIDC\nOauth2.0四种模式的场景\nOauth2.0\n开放平台鉴权以及OAuth2.0介绍 - duanxz - 博客园 (cnblogs.com)\n帮你深入理解OAuth2.0协议_SecCloud的专栏-CSDN博客_oauth2.0协议\nOAuth2.0协议 - 简书 (jianshu.com)\nOauth2.0 协议到底是干什么的？ - 知乎 (zhihu.com)\nOAuth 2.0 的一个简单解释 - 阮一峰的网络日志 (ruanyifeng.com)\nOAuth 2.0 的四种方式 - 阮一峰的网络日志 (ruanyifeng.com)\nGitHub OAuth 第三方登录示例教程 - 阮一峰的网络日志 (ruanyifeng.com)\n深入理解OAuth2.0 - duanxz - 博客园 (cnblogs.com)\nOAuth 的权限问题与信息隐忧 - duanxz - 博客园 (cnblogs.com)\n"},{
  "section": "Blog",
  "slug": "/blog/auth/oidc-%E8%AE%A4%E8%AF%81%E5%8D%8F%E8%AE%AE/",
  "title": "OIDC认证协议",
  "description": "OpenID Connect协议，允许第三方应用通过统一的认证中心进行身份认证，认证成功之后会返回ID token, 第三方应用可以据此建立会话。OIDC在OAuth2.0的基础上进行了身份认证的扩展，Oauth2.0拥有的授权功能，通常OIDC也可以支持。",
  "date": "2024年11月21日",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/auth/OIDC_hu_989b5ce85e6f0ea2.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"128\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/auth\\/OIDC_hu_24cb2185b72ee8aa.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/auth/OIDC_hu_126b52efdc070825.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/auth\\/OIDC_hu_4c0431cc01400f81.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "认证, 协议",
  "tags": "OIDC, 认证",
  "content":"介绍 OIDC是基于OAuth2.0的身份认证协议.以下简单介绍下Oauth2.0: Oauth2.0 授权协议\nOIDC OpenID Connect 协议，允许第三方应用通过统一的认证中心进行身份认证，认证成功之后会返回ID token, 第三方应用可以据此建立会话。OIDC在OAuth2.0的基础上进行了身份认证的扩展，Oauth2.0拥有的授权功能，通常OIDC也可以支持。\n关于认证和授权的区别 认证，Authentication，认证的目标是让第三方应用知道当前登录的用户是谁，在OIDC中第三方应用通过ID token能够直接解析出当前登录的用户信息。 授权，Authorization, 授权的目标是知道当前用户能干啥，可以不知道这个用户是谁，在OAuth2.0中用户在认证服务器中认证成功之后，会返回当前用户的Access Token,第三方应用可以拿着Access Token 来换取当前用户所需要的用户资源。\n如果当前用户的Access Token 允许访问的资源中包含了用户信息，也可以根据Access Token换取用户信息，但是这种获取用户信息的方式是根据授予的权限访问资源，偏向于授权的概念。\nOIDC中新增的概念 ID token：OIDC认证成功后返回的JWT,里面包含了用户信息 身份提供者（Identity Provider, IdP）:负责用户身份认证并颁发ID token, access token。\n相当于OAuth2.0的授权服务器，只是在OAuth 2.0的框架中，授权服务器的主要职责是处理授权请求和颁发访问令牌。它并不直接负责身份认证的过程,但它在实际应用中常常与身份认证过程相结合，与OIDC中的IdP相差不大\n第三方应用（Relying Party, RP）：通过IdP验证身份的应用，对应OAuth2.0的client 声明（Claims）：ID token中包含的字段信息，例如用户的用户名、邮箱、登录时间、令牌的有效期等。这些信息由身份提供者（Identity Provider，IdP）在身份验证过程中生成，并传递给客户端（Relying Party，RP）。\nClaims和Scopes Scope是客户端在发起授权请求时定义的一系列权限，决定了客户端能够访问用户的哪些信息或资源。OIDC定义了一些标准的Scope，如openid、profile、email等。Claims需要的信息也需要包含在scopes中才能获取到。\n流程 OIDC的流程与OAuth2.0基本一致，支持OAuth2.0中的授权码模式，隐式授权模式，密码模式和隐式授权（OIDC1.1弃用，因为会隐式授权id token access token直接返回到前端并不安全） 主要区别在于第六步中的响应结果中，相对于OAuth2.0多了ID token\n{ \u0026#34;access_token\u0026#34;: \u0026#34;ACCESS_TOKEN\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;Bearer\u0026#34;, \u0026#34;expires_in\u0026#34;: 3600, \u0026#34;id_token\u0026#34;: \u0026#34;ID_TOKEN\u0026#34;, \u0026#34;refresh_token\u0026#34;: \u0026#34;REFRESH_TOKEN\u0026#34; } ID Token eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.POstGetfAytaZS82wHcjoTyoqhMyxXiWdR7Nn7A29DNSl0EiXLdwJ6xC6AfgZWF1bOsS_TuYI3OG85AmiExREkrS6tDfTQ2B3WXlrr-wp5AokiRbz3_oB4OxG-W9KcEEbDRcZc0nH3L7LzYptiy1PtAylQGxHTWZXtGz4ht0bAecBgmpdgXMguEIcoqPJ1n3pIWk_dUZegpqx0Lka21H6XxUTxiy8OcaarA8zdnPUnV6AmNP3ecFawIFYdvJB_cm-GvpCSbr8G8y_Mllj8f4x9nBH8pQux89_6gUY618iYv7tuPWBFfEbLxtF2pZS6YC1aSfLQxeNe8djT9YjpvRZAQ 这个ID Token由三部分组成，分别是：\nHeader: 描述了JWT的签名算法和令牌类型。 Payload: 包含了关于用户身份和认证状态的实际信息。 Signature: 用于验证令牌完整性的签名。 以下是上述ID Token的解码后的Header和Payload部分： Header { \u0026#34;alg\u0026#34;: \u0026#34;RS256\u0026#34;, \u0026#34;typ\u0026#34;: \u0026#34;JWT\u0026#34; } Payload\n{ \u0026#34;sub\u0026#34;: \u0026#34;1234567890\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;admin\u0026#34;: true, \u0026#34;iat\u0026#34;: 1516239022 } 以下是Payload中各个字段的含义：\nsub (Subject)：主题，通常是用户的唯一标识符，例如用户ID。 name：用户的姓名。 admin：表示用户是否是管理员。 iat (Issued At)：令牌的发行时间戳。 参考 OIDC协议的概述和工作流程\nOAuth2.0 vs OIDC\nOauth2.0四种模式的场景\nOauth2.0\n关于OIDC，一种现代身份验证协议\n"},{
  "section": "Blog",
  "slug": "/blog/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/mybatis%E4%B8%8Espring-data-jpa%E7%9A%84%E5%AF%B9%E6%AF%94/",
  "title": "mybatis与SpringDataJPA的对比",
  "description": "除了面试背诵区别之外的一些对比",
  "date": "2024年2月15日",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/database/labixiaoxin_hu_20a63d69459d3f5d.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"207\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/database\\/labixiaoxin_hu_f6d366b7129dc88f.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/database/labixiaoxin_hu_2b31a4c726e9e5e2.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/database\\/labixiaoxin_hu_a3dfaa25afd621d3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "mybatis, spring data jpa",
  "tags": "mybatis, spring data jpa",
  "content":"ORM Object Relation Mapping 用于在面向对象编程语言和关系型数据库之间建立一种映射关系。 它允许开发人员使用面向对象的方式来操作数据库，而不是直接编写 SQL 语句。\nHibernate是基于ORM实现的，Spring Data JPA是基于Hibernate实现的。 因为mybatis需要编写SQL,但是能够实现查询结果到对象的映射，所以有把mybatis称为半ORM映射的说法。\nJPA JPA（Java Persistence API） JPA是ORM在java中的一种实现。 它不是一个具体的实现框架，而是定义了一系列的接口和规则，用于在 Java 环境中进行对象关系映射操作。这些规则包括如何定义实体类、实体类之间的关系、如何执行持久化操作等诸多方面。 JPA 作为一种规范，为不同的 ORM 框架提供了统一的接口标准。这意味着不同的 JPA 实现框架（如 Hibernate、EclipseLink 等）都需要遵循 JPA 定义的接口和规则来实现对象关系映射功能。开发人员在使用这些框架时，可以基于相同的 JPA 接口进行编程，而不用担心底层 ORM 框架的具体实现差异。 mybatis并没有遵循JPA的规范。\n表与类，列与字段的映射 @Entity，@Table,@Id,@Column 建立表与实体类的映射 @OneToOne、@OneToMany、@ManyToOne和@ManyToMany等注解用于映射一对一、一对多、多对一和多对多的关系。 mybatis构造的返回结果通常都是平铺的，而jpa能体现出对象的包含关系。\n@Entity @SuperBuilder @Table(name = \u0026#34;isp_XX_Item\u0026#34;) public class User { @Id @GeneratedValue(generator = \u0026#34;uuid_generator\u0026#34;) @GenericGenerator(name = \u0026#34;uuid_generator\u0026#34;, strategy = \u0026#34;uuid\u0026#34;) private String id; @Column(nullable = false) private String name; @Enumerated(EnumType.STRING) @Column(nullable = false) private String username; private String password; @OneToOne @JoinColumn(nullable = false, name = \u0026#34;item_key_id\u0026#34;, referencedColumnName = \u0026#34;id\u0026#34;) private KeyEntity key; } [!INFO] Spring Data JPA要求字段和属性名称存在映射关系，可以配置通用的映射：比如驼峰映射成下划线，也可以通过@Column配置将不相关的属性和字段绑定在一起。\nmybatis里面需要自己进行SQL编写，参数映射，结果映射，灵活，但是稍麻烦，以及要考虑SQL注入问题，Spring Data JPA通常情况下通过参数绑定的方式填充查询条件，只要不手写原生SQL，是不会出现SQL注入问题的（mybatis里面#避免SQL注入）。\n方法名查询\u0026amp;查询 JPQL \u0026amp; Criteria API 方法名生成查询 SysSettingEntity findByCategory(String category); Optional\u0026lt;SysSettingEntity\u0026gt; findByCategory(String category); JPQL // 查询 @Query(\u0026#34;select distinct vi.XX.id from XXXXEntity vi where vi.XX.delFlag=:deleteFlag and vi.delFlag=:deleteFlag and vi.XX.id in :XXIds\u0026#34;) List\u0026lt;String\u0026gt; findListByXXIdListAndDeleteFlag(@Param(\u0026#34;XXIds\u0026#34;) List\u0026lt;String\u0026gt; XXIds,@Param(\u0026#34;deleteFlag\u0026#34;) DeleteFlag deleteFlag); 原生SQL // 使用原生SQL实现的方法 @Query(value = \u0026#34;SELECT DISTINCT v.id \u0026#34; + \u0026#34;FROM XX_item vi \u0026#34; + \u0026#34;JOIN XX v ON vi.XX_id = v.id \u0026#34; + \u0026#34;WHERE v.del_flag = :deleteFlag \u0026#34; + \u0026#34;AND vi.del_flag = :deleteFlag \u0026#34; + \u0026#34;AND v.id IN (:XXIds)\u0026#34;, nativeQuery = true) List\u0026lt;String\u0026gt; findListByXXIdListAndDeleteFlag(@Param(\u0026#34;XXIds\u0026#34;) List\u0026lt;String\u0026gt; XXIds, @Param(\u0026#34;deleteFlag\u0026#34;) String deleteFlag); } Criteria API 复杂查询还是mybatis使用方便。 下面这种纯用java代码写sql,算是正统的复杂查询的编写方式。\n@Override public CustomPage\u0026lt;XXXXEntity\u0026gt; findByPage(XXXXSearchReq XXXXSearchReq) throws ServiceException { Sort sort = Sort.by(StringUtils.isNotBlank(XXXXSearchReq.getOrder()) \u0026amp;\u0026amp; Objects.equals(XXXXSearchReq.getOrder(), \u0026#34;descending\u0026#34;) ? Sort.Direction.DESC : Sort.Direction.ASC, StringUtils.isBlank(XXXXSearchReq.getOrderByColumn()) ? \u0026#34;name\u0026#34; : XXXXSearchReq.getOrderByColumn()); Pageable pageable = PageRequest.of(XXXXSearchReq.getPageNum(), XXXXSearchReq.getPageSize(), sort); Page\u0026lt;XXXXEntity\u0026gt; XXPage = XXXXRepository.findAll(buildSpecification(XXXXSearchReq), pageable); return XXCustomPage; } public Specification\u0026lt;XXXXEntity\u0026gt; buildSpecification(XXXXSearchReq XXXXSearchReq) { return new Specification\u0026lt;XXXXEntity\u0026gt;() { @Override public Predicate toPredicate(Root\u0026lt;XXXXEntity\u0026gt; root, CriteriaQuery\u0026lt;?\u0026gt; query, CriteriaBuilder criteriaBuilder) { List\u0026lt;Predicate\u0026gt; predicates = new ArrayList\u0026lt;\u0026gt;(); if (StringUtils.isNotBlank(XXXXSearchReq.getAll())) { String keyword = \u0026#34;%\u0026#34; + XXXXSearchReq.getAll() + \u0026#34;%\u0026#34;; Predicate nameCondition = criteriaBuilder.like(root.get(\u0026#34;name\u0026#34;), keyword); Predicate websiteCondition = criteriaBuilder.like(root.get(\u0026#34;website\u0026#34;), keyword); Predicate usernameCondition = criteriaBuilder.like(root.get(\u0026#34;username\u0026#34;), keyword); predicates.add(criteriaBuilder.or(nameCondition, websiteCondition, usernameCondition)); } else if (StringUtils.isNotBlank(XXXXSearchReq.getName())) { String keyword = \u0026#34;%\u0026#34; + XXXXSearchReq.getName() + \u0026#34;%\u0026#34;; Predicate nameCondition = criteriaBuilder.like(root.get(\u0026#34;name\u0026#34;), keyword); predicates.add(nameCondition); } else if (StringUtils.isNotBlank(XXXXSearchReq.getWebsite())) { String keyword = \u0026#34;%\u0026#34; + XXXXSearchReq.getWebsite() + \u0026#34;%\u0026#34;; Predicate nameCondition = criteriaBuilder.like(root.get(\u0026#34;website\u0026#34;), keyword); predicates.add(nameCondition); } LoginUser loginUser = SecurityUtils.getLoginUser(); predicates.add(criteriaBuilder.equal(root.get(\u0026#34;XX\u0026#34;).get(\u0026#34;id\u0026#34;), XXXXSearchReq.getXXId())); predicates.add(criteriaBuilder.equal(root.get(\u0026#34;delFlag\u0026#34;), DeleteFlag.NORMAL)); predicates.add(criteriaBuilder.equal(root.get(\u0026#34;updateBy\u0026#34;), loginUser.getUserId())); return criteriaBuilder.and(predicates.toArray(new Predicate[predicates.size()])); } }; } 对于不太复杂的场景中的if判断可以尝试下这种方式\n@Query(\u0026#34;from XXXX vi where vi.XX.id=:XXId and(:keyword is null OR(:keyword is not null and vi.name=:keyword)) and vi.delFlag=:deleteFlag\u0026#34;) Page\u0026lt;XXXXEntity\u0026gt; findByPage(@Param(\u0026#34;XXId\u0026#34;) String XXId, @Param(\u0026#34;keyword\u0026#34;) String keyword, @Param(\u0026#34;deleteFlag\u0026#34;) DeleteFlag deleteFlag, Pageable pageable); 第三方扩展QueryDSL\nQEmployee employee = QEmployee.employee; BooleanBuilder builder = new BooleanBuilder(); for (String name : names) { builder.or(employee.name.equalsIgnoreCase(name)); } if (id != null) { builder.and(employee.id.equals(id)) } queryFactory.selectFrom(employee).where(builder).fetch(); 缓存关联 一级缓存（L1 Cache）：JPA 的EntityManager自带一级缓存，在一个EntityManager的生命周期内，它会缓存已经加载的实体对象。例如，在同一次数据库会话中，多次查询同一个主键的实体对象，第一次查询后，后续查询可以直接从一级缓存中获取，提高了查询效率。 二级缓存（L2 Cache）：Spring Data JPA支持二级缓存，它是跨EntityManager的缓存。对于一些经常查询且数据不经常变化的实体对象，可以通过配置二级缓存来进一步提高性能。例如，对于系统配置信息这样的实体对象，使用二级缓存可以减少数据库的访问次数。 mybatis也有类似的功能。 数据库的兼容性问题 不同数据库的特殊的语法 增删改查中差异大且常用的只要就是分页，排序，函数，主键。\n分页，排序 -- MySQL SELECT * FROM users ORDER BY id LIMIT 20, 10; -- PostgreSQL SELECT * FROM users ORDER BY id LIMIT 10 OFFSET 20; -- PostgreSQL 10 SELECT * FROM orders ORDER BY order_date OFFSET 20 ROWS FETCH NEXT 10 ROWS ONLY; mybatis 集成 page helper mybatis plus的 MybatisPlusInterceptor Spring Data jpa的 Pageable\n都是相同的原理：通过不同数据库的方言得到不同的语法\n函数 SQL标准规定的函数比如聚合函数，字符串函数，现在主流的数据库都有支持，可能一些早期的数据库版本存在支持问题。\n-- 拼接 SELECT CONCAT(column1, column2) FROM table_name; --早期oracle SELECT column1 || column2 FROM table_name; JPQL提供了自己的函数，根据不同的方言可以转换为不同数据库的实现，目前来看mybatis的方言没有包括数据库函数的转换。\n主键 不同的数据库自生成主键的实现方式不同，MySQL自增主键，Oracle，PG是序列。 Spring Data Jpa 通过在实体类的ID字段上配置@GeneratedValue可以做到不同数据库适配不同的主键，同时Hibernate提供了UUID的实现，也可以在这里配置。 mybatis依靠useGeneratedKeys=\u0026ldquo;true\u0026rdquo;，可以在不同数据库生成不同类型的主键。\n其他 如果要做数据库兼容，使用mybatis的话，注意使用标准的SQL语法，尽量不要使用数据库自有的语法，加上数据库各自的方言也可以做到数据库兼容。 要考虑兼容不同数据库的话，解决这种不同数据库差异的问题,通常可以：\n数据库层面的配置。 重写特定数据库方言中的排序方法。 最后再考虑在SQL中添加自有语法，然后配置不同数据库调用不同的bean或者方法。 因为现在mybatis也做了很多去兼容不同数据库的改进，所以实际上SpringData JPA跟mybatis差别不大。 使用JPA编写持久层通常不使用原生SQL编写，更多的是使用方法名生成查询，JPQL，Criteria API来实现，这几种方式将编写的SQL限定在了标准SQL语法内，不会使用数据库特有的语法。对于需要特殊语法处理的操作，Spring Data JPA能够更早的发现。 切换数据库举例 Spring Data JPA支持主流的关系型数据库MySQL，Mariadb,Oracle,SqlServer,PG,H2,DB2等。 比如，目前iSensePassword查询方法是基于PG的，只要引入相关的驱动进行相应的配置调整就可以切换到另外的数据库，以下为MariaDB\nspring: datasource: url: jdbc:mysql://127.0.0.1:3308/isensepassword #数据库链接 driver-class-name: com.mysql.cj.jdbc.Driver username: root password: my-secret-pw jpa: database-platform: org.hibernate.dialect.MySQL8Dialect #数据库方言 SpringData JPA虽然不支持国产数据库，但是国产数据库通常都是基于某种开源的数据库或者存在某种数据库的兼容模式，通过对代码进行适量的调整，也可以让Spring Data JPA支持国产数据库。\n"},{
  "section": "Blog",
  "slug": "/blog/%E6%9D%82%E8%B0%88/%E6%A8%A1%E4%BB%BF%E8%80%85/",
  "title": "",
  "description": "",
  "date": "1年1月1日",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/database/labixiaoxin_hu_20a63d69459d3f5d.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"207\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/database\\/labixiaoxin_hu_f6d366b7129dc88f.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/database/labixiaoxin_hu_2b31a4c726e9e5e2.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/database\\/labixiaoxin_hu_a3dfaa25afd621d3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "",
  "tags": "",
  "content":""},{
  "section": "Blog",
  "slug": "/blog/%E6%9D%82%E8%B0%88/%E8%AF%8D%E5%8F%A5/",
  "title": "",
  "description": "",
  "date": "1年1月1日",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/database/labixiaoxin_hu_20a63d69459d3f5d.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"207\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/database\\/labixiaoxin_hu_f6d366b7129dc88f.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/database/labixiaoxin_hu_2b31a4c726e9e5e2.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/database\\/labixiaoxin_hu_a3dfaa25afd621d3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "",
  "tags": "",
  "content":""}]
